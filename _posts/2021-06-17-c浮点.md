---
layout:     post
title:      C语言学习总结：浮点型在内存中的存储
subtitle:   C语言学习总结：浮点型在内存中的存储
date:       2021-06-29
author:     YS
catalog: true
tags:
    - 浮点型
---

我们都知道，对于整形来说，数据存放内存中存放的是补码。但是对于[浮点型](https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E5%9E%8B&spm=1001.2101.3001.7020)来说，在内存中存放的是否也是补码呢？

举个例子：

    #define _CRT_SECURE_NO_WARNINGS 1 #include<stdio.h> int main(){	int n = 9;	float *pFloat = (float *)&n;//强制转换类型	printf("n的值为:%d\n",n);	printf("*pFloat的值为:%f\n",*pFloat); 	*pFloat = 9.0;	printf("num的值为:%d\n",n);	printf("*pFloat的值为:%f\n",*pFloat);	return 0;}

![](https://i-blog.csdnimg.cn/blog_migrate/194f5e4002557ae850e2c9b7544a4ffd.png)

num和\*pFloat中存放的是同一个数，但是结果却不一样。所以，浮点型的存储方式一定和整形是不一样的。

那么，浮点型数据是怎么存储的呢？

1.根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制[浮点数](https://so.csdn.net/so/search?q=%E6%B5%AE%E7%82%B9%E6%95%B0&spm=1001.2101.3001.7020)可以表示为下面的形式：

**（-1）^S\*M\*2^E**

a.(-1)^S表示符号位，当S=0时，表示正数，当S=1时，表示负数。

b.M表示有效数字，大于等于1，小于2。

c.2^E表示指数位。

例如：5.5写成二进制为101.1，相当于1.011\*2^2，那么，S=0，M=1.011,E=2。

2.IEEE 745规定：对于32位的浮点数，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M。

![](https://i-blog.csdnimg.cn/blog_migrate/49dfc76492f1e2b40853b6341c40f968.png)

                                                                   单精度浮点数存储模型

对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

![](https://i-blog.csdnimg.cn/blog_migrate/e830c15570fd9226c2133b8abcf75199.png)

                                                                       双精度浮点数存储模型

3.IEEE 754对有效数字M和指数E，还有一些特别规定。

**有效数字M**：1<M<2,也就是说，M写成1.xxxxxxx的形式，其中xxxxxxx表示小数部分。

IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存小数部分。比如保存1.011时，只保存011，后面的位数补0就可以了，等到读取的时候，再把第一位的1补上去。

**指数E**:

首先，E为一个无符号整数（unsigned int）

如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法是可以出现负数的，所以IEEE 754规定，存入内存的E是真实值加上一个中间数，对于8位的E，中间数是127，对于11位的E，中间数是1023。比如，2^2的E是2，所以保存为32位浮点数时，必须保存为2+127=129，即10000001。

然后，指数E还可以被分为三种情况：

**E不全为0或不全为1**

这个就是正常情况，取出内存中的数时，指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。

**E全为0**

这时，浮点数的指数E等于1-127（或1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxxx的小数。这样做是为了表示正负零，以及接近于0的很小的数字。

**E全为1**

这时，有效数字M全为0，表示正负无穷大。

好了，现在我们回到刚开始的例题，在第一部分中，整形数字9若还原成浮点数就变成了0，这是为什么呢？

首先，将00000000000000000000000000001001拆分，第一位符号位S=0,后面8位的指数E=00000000，最后23位有效数字M=00000000000000000001001。由于指数E全为0，符合上述第二种情况，因此，浮点数是一个很小的接近于0的正数，所以用十进制小数表示为0.000000。

在第二部分中，浮点数9.0用十进制表示是一个很大的数。这又是为什么呢？

首先，浮点数9.0等于二进制的1001.0，即1.001\*2^3。那么，S=0,M=1.001,E=3+127=130。

就是这样：0 10000010 00100000000000000000000

这个32位的二进制数，还原成十进制数，正是1091567616。